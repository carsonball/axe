use stdlib/arena (
    Arena
);

use stdlib/memory (
    copy,
    size_of
);

macro make_list(name: string, type: string) {
    model name {
        data: ref type;
        length: int;
        cap: int;

        def new_list(arena: ref Arena, capacity: int): ref name {
            mut val lst: ref name = Arena.alloc(arena, size_of(name));
            lst.data = Arena.alloc_array(arena, size_of(type), capacity);
            lst.length = 0;
            lst.cap = capacity;
            return lst;
        }

        def push(lst: ref name, arena: ref Arena, value: type) {
            if lst.length >= lst.cap {
                val new_cap: int = lst.cap * 2;
                mut val new_data: ref type = Arena.alloc_array(arena, size_of(type), new_cap);
                copy(lst.data[0], new_data[0], type[lst.length]);
                lst.data = new_data;
                lst.cap = new_cap;
            }
            lst.data[lst.length] = value;
            lst.length = lst.length + 1;
        }

        def get(lst: ref name, index: int): type {
            if index < 0 or index >= lst.length {
                println "Index out of bounds!";
                return 0;
            }
            return lst.data[index];
        }

        def print_all(lst: ref name) {
            for mut val i = 0; i < lst.length; i++ {
                print lst.data[i];
                print " ";
            }
            println "";
        }
    }
}

make_list(IntList, int);


test {
    mut val arena: Arena = Arena.create(65536);
    mut val my_list: ref IntList = IntList.new_list(ref_of(arena), 4);

    IntList.push(my_list, ref_of(arena), 10);
    IntList.push(my_list, ref_of(arena), 20);
    IntList.push(my_list, ref_of(arena), 30);
    IntList.push(my_list, ref_of(arena), 40);
    IntList.push(my_list, ref_of(arena), 50);

    println "IntList contents:";
    IntList.print_all(my_list);

    println "Element at index 2:";
    println IntList.get(my_list, 2);

    Arena.destroy(ref_of(arena));
}
