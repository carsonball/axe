use std/string (
    string
);
use std/io (
    print_str
);
use std/errors (
    error, panic
);
use std/lists (
    StringList
);
use std/arena (
    Arena
);

/// Execute a shell command. Returns exit status.
def exec_from_string(cmd: string): i32 {
    mut val result: i32 = 0;
    raw {
        result = system(cmd.data);
    }
    return result;
}

/// Execute a shell command with raw C string.
/// Returns exit status.
def exec(cmd: char*): i32 {
    mut val result: i32 = 0;
    raw {
        result = system(cmd);
    }
    return result;
}

/// Check if a file exists.
def file_exists(path: string): bool {
    mut val out: bool = false;
    raw {
        FILE *f = fopen(path.data, "r");
        if (f != NULL) {
            fclose(f);
            out = true;
        }
    }
    return out;
}

/// Read entire file into a newly allocated string.
def read_file(path: string): string {
    mut val out: string;

    raw {
        FILE *f = fopen(path.data, "rb");
        if (!f) {
            std_errors_panic(std_errors_error_create("Failed to open file"));
        }

        fseek(f, 0, SEEK_END);
        long size = ftell(f);
        fseek(f, 0, SEEK_SET);

        char *buf = (char*)malloc(size + 1);
        fread(buf, 1, size, f);
        buf[size] = 0;
        fclose(f);

        out = std_string_string_create(buf);
    }

    return out;
}

/// Write a string to a file, replacing its contents.
/// Returns true on success.
def write_file(path: string, contents: string): bool {
    mut val ok: bool = false;

    raw {
        FILE *f = fopen(path.data, "wb");
        if (!f) {
            return false;
        }
        fwrite(contents.data, 1, contents.len, f);
        fclose(f);
        ok = true;
    }

    return ok;
}

use external("sys/stat.h");
use external("sys/types.h");

/// Determine if a path is a directory.
def is_directory(path: string): bool {
    mut val out: bool = false;

    platform posix {
        raw {
            struct stat sb;
            if (stat(path.data, &sb) == 0) {
                out = S_ISDIR(sb.st_mode);
            }
        }
    }

    platform windows {
        raw {
            struct _stat sb;
            if (_stat(path.data, &sb) == 0) {
                out = (sb.st_mode & _S_IFDIR) != 0;
            }
        }
    }

    return out;
}

/// Determine if a path is a regular file.
def is_file(path: string): bool {
    mut val out: bool = false;

    platform posix {
        raw {
            struct stat sb;
            if (stat(path.data, &sb) == 0) {
                out = S_ISREG(sb.st_mode);
            }
        }
    }

    platform windows {
        raw {
            struct _stat sb;
            if (_stat(path.data, &sb) == 0) {
                out = (sb.st_mode & _S_IFREG) != 0;
            }
        }
    }

    return out;
}

/// Determine if a path is a symbolic link.
/// This always returns false on Windows.
def is_symbolic_link(path: string): bool {
    mut val out: bool = false;

    platform posix {
        raw {
            struct stat sb;
            if (lstat(path.data, &sb) == 0) {
                out = S_ISLNK(sb.st_mode);
            }
        }
    }

    platform windows {
        return false;
    }
    return out;
}

/// Delete a file.
def delete_file(path: string): bool {
    mut val ok: bool = false;
    raw {
        if (remove(path.data) == 0) {
            ok = true;
        }
    }
    return ok;
}

/// Delete some directory. It must be empty.
def rm_dir(path: string): bool {
    mut val ok: bool = false;
    raw {
        if (rmdir(path.data) == 0) {
            ok = true;
        }
    }
    return ok;
}

platform windows {
    use external("io.h");
    use external("direct.h");
}

platform posix {
    use external("dirent.h");
}

/// Delete some directory, it does NOT have to be empty.
/// Use with caution.
def rm_dir_recursive(path: string): bool {
    mut val ok: bool = true;

    platform posix {
        raw {
            DIR *d = opendir(path.data);
            size_t path_len = strlen(path.data);
            int r = 0;

            if (d) {
                struct dirent *p;
                r = 0;
                
                while (!r && (p = readdir(d))) {
                    if (!strcmp(p->d_name, ".") || !strcmp(p->d_name, "..")) {
                        continue;
                    }

                    size_t len = path_len + strlen(p->d_name) + 2;
                    char *buf = malloc(len);
                    if (!buf) {
                        r = -1;
                        break;
                    }
                    snprintf(buf, len, "%s/%s", path.data, p->d_name);

                    struct stat statbuf;
                    if (!stat(buf, &statbuf)) {
                        if (S_ISDIR(statbuf.st_mode)) {
                            if (!rm_dir_recursive(std_string_string_create(buf))) {
                                r = -1;
                            }
                        } else {
                            if (remove(buf)) {
                                r = -1;
                            }
                        }
                    } else {
                        r = -1;
                    }
                    free(buf);
                }
                closedir(d);
            }
            
            if (!r) {
                if (rmdir(path.data) != 0) {
                    r = -1;
                }
            }
            
            if (r != 0) {
                ok = false;
            }
        }
    }

    platform windows {
        raw {
            struct _finddata_t fileinfo;
            char search_path[MAX_PATH];
            int handle;
            int r = 0;
            snprintf(search_path, MAX_PATH, "%s\\*", path.data);
            
            handle = _findfirst(search_path, &fileinfo);
            
            if (handle != -1) {
                do {
                    if (!strcmp(fileinfo.name, ".") || !strcmp(fileinfo.name, "..")) {
                        continue;
                    }

                    char sub_path[MAX_PATH];
                    snprintf(sub_path, MAX_PATH, "%s\\%s", path.data, fileinfo.name);
                    
                    if (fileinfo.attrib & _A_SUBDIR) {
                        if (!rm_dir_recursive(std_string_string_create(sub_path))) {
                             r = -1;
                        }
                    } else {
                        if (remove(sub_path)) {
                            r = -1;
                        }
                    }
                } while (_findnext(handle, &fileinfo) == 0 && r == 0);
                
                _findclose(handle);
            }
            
            if (r == 0) {
                if (rmdir(path.data) != 0) {
                    r = -1;
                }
            }

            if (r != 0) {
                ok = false;
            }
        }
    }

    return ok;
}

/// Internal helper to collect files recursively into a StringList.
def collect_files_recursive(path: string, result: ref StringList, arena: ref Arena) {
    platform posix {
        raw {
            DIR *d = opendir(path.data);
            if (!d) {
                return;
            }

            struct dirent *p;
            while ((p = readdir(d))) {
                if (!strcmp(p->d_name, ".") || !strcmp(p->d_name, "..")) {
                    continue;
                }

                size_t len = strlen(path.data) + strlen(p->d_name) + 2;
                char *buf = (char*)malloc(len);
                if (!buf) {
                    continue;
                }

                snprintf(buf, len, "%s/%s", path.data, p->d_name);

                struct stat statbuf;
                if (!stat(buf, &statbuf)) {
                    if (S_ISDIR(statbuf.st_mode)) {
                        struct std_string_string sub_path = std_string_string_create(buf);
                        collect_files_recursive(sub_path, result, arena);
                    } else if (S_ISREG(statbuf.st_mode)) {
                        struct std_string_string file_path = std_string_string_create(buf);
                        std_lists_StringList_push((struct std_lists_StringList*)result, arena, file_path);
                    }
                }

                free(buf);
            }

            closedir(d);
        }
    }

    platform windows {
        raw {
            struct _finddata_t fileinfo;
            char search_path[MAX_PATH];
            intptr_t handle;

            snprintf(search_path, MAX_PATH, "%s\\*", path.data);

            handle = _findfirst(search_path, &fileinfo);
            if (handle == -1) {
                return;
            }

            do {
                if (!strcmp(fileinfo.name, ".") || !strcmp(fileinfo.name, "..")) {
                    continue;
                }

                char sub_path[MAX_PATH];
                snprintf(sub_path, MAX_PATH, "%s\\%s", path.data, fileinfo.name);

                if (fileinfo.attrib & _A_SUBDIR) {
                    struct std_string_string sub_path_str = std_string_string_create(sub_path);
                    collect_files_recursive(sub_path_str, result, arena);
                } else {
                    struct std_string_string file_path = std_string_string_create(sub_path);
                    std_lists_StringList_push((struct std_lists_StringList*)result, arena, file_path);
                }
            } while (_findnext(handle, &fileinfo) == 0);

            _findclose(handle);
        }
    }
}

/// List all regular files recursively under `path`.
def list_files_recursive(path: string, arena: ref Arena): ref StringList {
    mut val result: ref StringList;
    result = StringList.create(arena, 16);
    collect_files_recursive(path, result, arena);
    return result;
}

/// Get commandline args
def get_cmdline_args(arena: ref Arena): ref StringList {
    mut val result: ref StringList;
    result = StringList.create(arena, 10);
    
    raw {
        int argc = 0;
        char **argv = (char**)__axe_argv;
        while (argv[argc] != NULL) {
            argc++;
        }
        for (int i = 0; i < argc; i++) {
            struct std_string_string str = std_string_string_create(argv[i]);
            std_lists_StringList_push((struct std_lists_StringList*)result, arena, str);
        }
    }
    
    return result;
}

test {
    assert(exec("echo test") == 0, "exec should run successfully");
    assert(write_file(string.create("testfile.txt"), string.create("hello")), "write_file should succeed");
    assert(file_exists(string.create("testfile.txt")), "file should exist after writing");
    assert(is_file(string.create("testfile.txt")), "testfile.txt should be a file");
    assert(is_directory(string.create(".")), "current directory should be a directory");
    assert(!is_symbolic_link(string.create("testfile.txt")), "testfile.txt should not be a symbolic link");
    assert(delete_file(string.create("testfile.txt")), "delete_file should succeed");
    assert(!file_exists(string.create("testfile.txt")), "file should not exist after deletion");

    mut val arena: Arena = Arena.create(65536);
    val args: ref StringList = get_cmdline_args(ref_of(arena));
    assert(args.len >= 1, "there should be at least one commandline argument");

    print "(And that commandline argument is: ";
    
    for arg in args {
        print_str(arg);
    }

    print ")\n";
}
