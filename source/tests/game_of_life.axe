use std.term(clear_screen);
use std.time(wait);
use std.random(randomize, random);
use std.io;

/// Convert 2D coordinate (x, y) into 1D index
def idx(x: i32, y: i32, width: i32): i32 {
    return y * width + x;
}

/// Print the grid (1-D array)
def print_grid(grid: ref i32[], width: i32, height: i32) {
    for mut y = 0; y < height; y++ {
        for mut x = 0; x < width; x++ {
            if grid[idx(x, y, width)] == 1 {
                print "■";
            } else {
                print "□";
            }
        }
        println "";
    }
}

/// Count live neighbors around (x, y)
def count_neighbors(grid: ref i32[], x: i32, y: i32, width: i32, height: i32): i32 {
    mut count: i32 = 0;

    for mut dy = -1; dy <= 1; dy++ {
        for mut dx = -1; dx <= 1; dx++ {
            if dx == 0 and dy == 0 {
                continue;
            }

            val nx = x + dx;
            val ny = y + dy;

            if nx >= 0 and nx < width and ny >= 0 and ny < height {
                if grid[idx(nx, ny, width)] == 1 {
                    count = count + 1;
                }
            }
        }
    }

    return count;
}

/// Compute next generation
def next_generation(grid: ref i32[], new_grid: ref i32[], width: i32, height: i32) {
    for mut y = 0; y < height; y++ {
        for mut x = 0; x < width; x++ {

            val i = idx(x, y, width);
            val neighbors = count_neighbors(grid, x, y, width, height);

            if grid[i] == 1 {
                if neighbors == 2 or neighbors == 3 {
                    new_grid[i] = 1;
                } else {
                    new_grid[i] = 0;
                }
            } else {
                if neighbors == 3 {
                    new_grid[i] = 1;
                } else {
                    new_grid[i] = 0;
                }
            }
        }
    }
}

/// Copy new_grid back into grid
def copy_grid(src: ref i32[], dst: ref i32[], size: i32) {
    for mut i = 0; i < size; i++ {
        dst[i] = src[i];
    }
}

main {
    randomize();
    
    val width: i32 = 20;
    val height: i32 = 20;
    val size: i32 = width * height;

    mut grid: i32[size];
    mut new_grid: i32[size];

    for mut i = 0; i < size; i++ {
        new_grid[i] = 0;
        if random(0, 100) < 25 {
            grid[i] = 1;
        } else {
            grid[i] = 0;
        }
    }

    println "Conway's Game of Life (Random Start)\n";

    for mut gen = 0; gen < 20000; gen++ {
        wait(1);
        clear_screen();
        print "Generation ";
        println gen;
        println "";

        print_grid(grid, width, height);

        next_generation(grid, new_grid, width, height);
        copy_grid(new_grid, grid, size);

        println "\n---\n";
    }
}
